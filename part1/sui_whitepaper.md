# Sui : 一个新的智能合约平台

## 1.介绍
Sui是一个分布式、开放的智能合约平台，侧重于低延时的去管理资产。它使用Move编程语言来将资产定义为可能属于某个地址的对象。Move程序定义了对这些类型化了的对象的操作，包括自定义初始化规则、资产如何传递给新的拥有者、以及改变资产的操作。Sui是由一组无权限的节点(authorities)维护，这些节点的角色类似于其他区块链中的验证器或是矿工。它在授权机构之间使用拜占庭一致的广播协议，以确保对资产进行操作的安全性。与拜占庭协议相比，确保了更低的延迟和更好的可伸缩性。它仅依赖于拜占庭协议来保证共享对象的安全，以及在关键延迟路径之外执行的治理操作和检查点。在某些情况下，智能合约的执行也会自然地并行化。Sui支持轻客户端来验证读取，也支持完整的客户端来审核所有状态转换的完整性。这些设施允许与其他类型的区块链建设的信任最小化的桥梁。

链上原生资产SUI代币用来支付所有链上操作的gas费用。SUI代币也被它的所有者用来在不同epoch内委托质押给不同的节点来管理Sui。这些节点会定期的根据这些委托质押给他们的SUI来重置配置。被使用的gas会根据分配给这些节点，还有根据质押SUI的比例分配给质押者们。

本白皮书氛围两部分，第二部分描述了基于Move语言的Sui编程模型，第四部分描述了确保Sui的安全性、活跃性和性能的无许可去中心化分布式系统的操作。


## 2.Sui智能合约编程
Sui的智能合约是用Move语言编写的。Move安全且富有表现力，其类型系统和数据模型天然支持并行协议/执行操作来使得Sui具有很强的可伸缩性。Move是一种用来构建智能合约的开源编程语言，最开始是在Facebook为了Diem区块链开发的。Move语言和平台无关，除了被Sui采用之外，它在其他平台（比如OL，StarCoin）也越来越受欢迎。

在本节中，我们主要会讨论关于Move语言的一些重要特性，并且解释如何使用它在Sui上创建和管理资产。关于Move的更全面解释可以在《Move Programming Language》里找到，更对针对Sui的Move内容可以在《Sui开发者门户》里找到，关于Sui上下文中Move的更正式的描述可以在第3节中找到。


### 2.1 概述
Sui的全局状态包括一个可编程的对象池，由Move包来创建和管理，这些可编程对象是包含Move函数和类型的Move模块的集合(详见2.1.1节)。Move包本身也是对象。因此，Sui中描述的对象可以分为以下两类：

- 结构数据值：由Move模块控制的类型化数据。每个对象都是一个结构值，其字段可以包含基本类型(比如整数、地址)、其他对象和非对象结构。
- 包码值(Package code values): 一组作为原子单元被发布的Move字节码模块集合。包中的每个模块既可以依赖于该包中的其他模块，也可以依赖于以前发布的包中的模块。

对象可以对资产进行编码(比如同质化代币/非同质化代币)，授予调用某些函数或创建其他对象的权限的功能，管理其他资产的“智能合约”等。这些全都由程序员们来决定。

声明自定义的Sui对象类型的Move代码如下所示：
```java
    struct Obj has key {
        id:VersionedID, // globally unique ID and version 
        f: u64 // objects can have primitive fields
        g: OtherObj // fields can also store other objects
    }
```
所有表示Sui对象的结构（但不是所有的Move结构值）必须具有id字段和值能力(key ability)，表明值可以存储在Sui的全局对象池中。

#### 2.1.1 模块
Move程序被组织为一组模块，每个模块由结构声明和函数声明的列表组成。一个模块可以从其他模块导入结构类型，并调用由其他模块声明的函数。

在一个Move模块中声明的值可以流动(flow)到另一个模块中，比如上面举例的模块Obj可以定义在与定义Obj的模块不同的模块中。这与大多数智能合约语言不同，后者只允许非结构化的字节跨合约边界流动。但是，Move能够支持这一点，因为它提供了封装特性来帮助程序员编写健壮性强的代码。具体来说，Move的类型系统确保了像上面的Obj这样的类型只能由声明该类型的模块中的函数创建、销毁、复制、读取和写入。这允许模块对其声明的类型强制强不变量，即使它们在流经智能合约信任边界时也会继续保持。

#### 2.1.2 事务(transaction)和入口点(entrypoint)

全局对象池可以通过创建、销毁、读写对象的事务进行更新。事务必须接受希望操作的每个现有对象作为输入。

此外，事务必须包括包对象的版本ID、包内模块、函数的名称以及函数的参数（包括输入对象）。

例如调用下面这个函数：

```java
public fun entrypoint {
    o1: Obj, o2: &mut Obj, o3: &Obj, x: u64, ctx: &mut TxContext
} { ... }
```

事务必须为三个类型为Obj的不同对象提供ID，并为绑定到x的整数提供ID。
TxContext是由运行时填充的特殊参数，其中包含创建新对象所需的发送方地址和信息。

入口点（更一般地说，是任何Move函数）的输入可以通过在类型中编码的不同的可变性权限来传递。可以读取、写入、传输或销毁Obj输入。一个&mut Obj输入只能读或写，而一个& Obj 只能读。事务发送方必须被授权使用具有指定的可变权限的每个输入对象 -- 详见4.4节。

#### 2.1.3 创建和传输对象 

程序员可以通过使用传入入口点的TxContext来创建对象，为对象生成一个新的ID：

```java
    public fun create_then_transfer(
    f: u64, g: OtherObj, o1: Obj, ctx: &mut TxContext
    ) {
    let o2 = Obj { id: TxContext::fresh_id(ctx), f, g };
    Transfer::transfer(o1, TxContext:sender());
    Transfer::transfer(o2, TxContext:sender());
    }
```
这段代码接受OtherObj和Obj类型的两个对象作为输入，使用第一个对象和生成的ID创建一个新的Obj，然后将两个obj对象传输给事务发送方。一旦传输了对象，它就会流到全局对象池中，并且在事务的其余部分中不能通过代码访问。Transfer模块是Sui标准库的一部分，它包含了将对象传输到用户地址和其他对象的函数。

我们注意到，如果程序员代码忽略了包含一个转移调用，那么Move的类型系统将会拒绝该代码。Move强制资源安全保护，以确保在没有权限的情况下不能创建、复制或意外销毁对象。资源安全的另一个例子是试图两次传输相同的对象，这也会被Move类型系统拒绝。


## 3.自编程模型

在本节中，我们将通过详细的语义定义来扩展第2节中对Sui编程模型的非正式描述。上一节展示了Move源代码的示例，示例里定义了Move字节码的结构。开发人员在本地编写、测试并正式验证Move源码，然后将其编译为字节码，再将其发布到区块链。任何发布在链上的Move字节码必须通过字节码验证器，以确保它满足关键属性，如类型、内存和资源安全。

正如在第2节中提到的，Move是一种平台无关的语言，它可以适应不同系统的特定需求，而不需要创建核心语言。在下面的描述中，我们从核心的Move语言(用黑色表示)中定义了这两个概念以及扩展核心Move语言的Sui-specific特性 (Instr 后的值 )。


### 3.1 模块
```java
Module = ModuleName×
(StructName ⇀ StructDecl)×
(FunName ⇀ FunDecl) × FunDecl
GenericParam = [Ability]
StructDecl = (FieldName ⇀ StorableType)×
[Ability] × [GenericParam]
FunDecl = [Type] [Type] × [Instr] × [GenericParam]
Instr = TransferToAddr | TransferToObj | ShareMut | ShareImmut | . . .

```

Move代码被组织到模块中，其结构定义如上所示。一个模块由一组命名结构体声明和一组命名函数声明组成(这些声明的例子在第2.1节中提供)。
模块还包含一个特殊的函数声明，作为模块初始化器。这个函数在模块发布到链上时只调用一次。

结构声明是命名字段的集合，其中字段名映射到可存储类型。它的声明还包括一个可选的能力列表(参见第2节的可存储类型和能力的描述)。struct声明还可以包括具有能力约束的泛型参数列表，在这种情况下，我们称其为泛型struct声明，例如struct Wrapper<T: copy>{T: T}。

泛型参数表示在声明结构字段时要使用的类型——在声明结构时它是未知的，而在实例化结构时提供了具体类型(例如：创建结构值时)。

函数声明包括形参类型列表、返回类型列表和组成函数体的指令列表。函数声明还可以包括具有能力约束的泛型参数列表，在这种情况下，我们称其为泛型函数声明，例如fun unwrap<T: copy>(p: Wrapper<T>){}。与struct声明类似，泛型形参表示在函数声明时未知的类型，但在声明函数形参、返回值和函数体时使用(在调用函数时提供具体类型)。

可以出现在函数体中的指令包括所有普通的Move指令，但全局存储指令除外(例如，move_to, move_from, borrow_global)。请参阅结尾的Move指令集以获得核心Move指令及其语义的完整列表。在Sui中，持久存储是通过Sui的全局对象池来支持的，而不是核心Move中基于账户的全局存储。

有四个特定于sui的对象操作。这些操作都会改变对象的所有权元数据(参见3.3节)，并将其返回给全局对象池。

最简单的是，一个Sui对象可以被转移到一个Sui最终用户的地址。对象还可以被转移到另一个父对象—此操作要求调用方提供对中父对象的可变引用添加到子对象。对象可以被可变地共享，因此它可以被Sui系统中的任何人读/写。最后，一个对象可以不可更改地共享，这样它就可以被Sui系统中的任何人读取，但不能被任何人编写。

区分不同类型所有权的能力是Sui的一个独特特征。在我们知道的其他区块链平台中，每个合约和对象都是可变地共享的。正如我们将在第4节中解释的，Sui利用该信息进行并行事务执行(针对所有事务)和并行协议(针对涉及没有共享可变性的对象的事务)。