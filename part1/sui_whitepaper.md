# Sui : 一个新的智能合约平台

## 1.介绍
Sui是一个分布式、开放的智能合约平台，侧重于低延时的去管理资产。它使用Move编程语言来将资产定义为可能属于某个地址的对象。Move程序定义了对这些类型化了的对象的操作，包括自定义初始化规则、资产如何传递给新的拥有者、以及改变资产的操作。Sui是由一组无权限的验证者(authorities)维护，这些验证者的角色类似于其他区块链中的验证器或是矿工。它在授权机构之间使用拜占庭一致的广播协议，以确保对资产进行操作的安全性。与拜占庭协议相比，确保了更低的延迟和更好的可伸缩性。它仅依赖于拜占庭协议来保证共享对象的安全，以及在关键延迟路径之外执行的治理操作和检查点。在某些情况下，智能合约的执行也会自然地并行化。Sui支持轻客户端来验证读取，也支持完整的客户端来审核所有状态转换的完整性。这些设施允许与其他类型的区块链建设的信任最小化的桥梁。

链上原生资产SUI代币用来支付所有链上操作的gas费用。SUI代币也被它的所有者用来在不同epoch内委托质押给不同的验证者来管理Sui。这些验证者会定期的根据这些委托质押给他们的SUI来重置配置。被使用的gas会根据分配给这些验证者，还有根据质押SUI的比例分配给质押者们。

本白皮书氛围两部分，第二部分描述了基于Move语言的Sui编程模型，第四部分描述了确保Sui的安全性、活跃性和性能的无许可去中心化分布式系统的操作。


## 2.Sui智能合约编程
Sui的智能合约是用Move语言编写的。Move安全且富有表现力，其类型系统和数据模型天然支持并行协议/执行操作来使得Sui具有很强的可伸缩性。Move是一种用来构建智能合约的开源编程语言，最开始是在Facebook为了Diem区块链开发的。Move语言和平台无关，除了被Sui采用之外，它在其他平台（比如OL，StarCoin）也越来越受欢迎。

在本节中，我们主要会讨论关于Move语言的一些重要特性，并且解释如何使用它在Sui上创建和管理资产。关于Move的更全面解释可以在《Move Programming Language》里找到，更对针对Sui的Move内容可以在《Sui开发者门户》里找到，关于Sui上下文中Move的更正式的描述可以在第3节中找到。


### 2.1 概述
Sui的全局状态包括一个可编程的对象池，由Move包来创建和管理，这些可编程对象是包含Move函数和类型的Move模块的集合(详见2.1.1节)。Move包本身也是对象。因此，Sui中描述的对象可以分为以下两类：

- 结构数据值：由Move模块控制的类型化数据。每个对象都是一个结构值，其字段可以包含基本类型(比如整数、地址)、其他对象和非对象结构。
- 包码值(Package code values): 一组作为原子单元被发布的Move字节码模块集合。包中的每个模块既可以依赖于该包中的其他模块，也可以依赖于以前发布的包中的模块。

对象可以对资产进行编码(比如同质化代币/非同质化代币)，授予调用某些函数或创建其他对象的权限的功能，管理其他资产的“智能合约”等。这些全都由程序员们来决定。

声明自定义的Sui对象类型的Move代码如下所示：
```java
    struct Obj has key {
        id:VersionedID, // globally unique ID and version 
        f: u64 // objects can have primitive fields
        g: OtherObj // fields can also store other objects
    }
```
所有表示Sui对象的结构（但不是所有的Move结构值）必须具有id字段和值能力(key ability)，表明值可以存储在Sui的全局对象池中。

#### 2.1.1 模块
Move程序被组织为一组模块，每个模块由结构声明和函数声明的列表组成。一个模块可以从其他模块导入结构类型，并调用由其他模块声明的函数。

在一个Move模块中声明的值可以流动(flow)到另一个模块中，比如上面举例的模块Obj可以定义在与定义Obj的模块不同的模块中。这与大多数智能合约语言不同，后者只允许非结构化的字节跨合约边界流动。但是，Move能够支持这一点，因为它提供了封装特性来帮助程序员编写健壮性强的代码。具体来说，Move的类型系统确保了像上面的Obj这样的类型只能由声明该类型的模块中的函数创建、销毁、复制、读取和写入。这允许模块对其声明的类型强制强不变量，即使它们在流经智能合约信任边界时也会继续保持。

#### 2.1.2 事务(transaction)和入口点(entrypoint)

全局对象池可以通过创建、销毁、读写对象的事务进行更新。事务必须接受希望操作的每个现有对象作为输入。

此外，事务必须包括包对象的版本ID、包内模块、函数的名称以及函数的参数（包括输入对象）。

例如调用下面这个函数：

```java
public fun entrypoint {
    o1: Obj, o2: &mut Obj, o3: &Obj, x: u64, ctx: &mut TxContext
} { ... }
```

事务必须为三个类型为Obj的不同对象提供ID，并为绑定到x的整数提供ID。
TxContext是由运行时填充的特殊参数，其中包含创建新对象所需的发送方地址和信息。

入口点（更一般地说，是任何Move函数）的输入可以通过在类型中编码的不同的可变性权限来传递。可以读取、写入、传输或销毁Obj输入。一个&mut Obj输入只能读或写，而一个& Obj 只能读。事务发送方必须被授权使用具有指定的可变权限的每个输入对象 -- 详见4.4节。

#### 2.1.3 创建和传输对象 

程序员可以通过使用传入入口点的TxContext来创建对象，为对象生成一个新的ID：

```java
    public fun create_then_transfer(
    f: u64, g: OtherObj, o1: Obj, ctx: &mut TxContext
    ) {
    let o2 = Obj { id: TxContext::fresh_id(ctx), f, g };
    Transfer::transfer(o1, TxContext:sender());
    Transfer::transfer(o2, TxContext:sender());
    }
```
这段代码接受OtherObj和Obj类型的两个对象作为输入，使用第一个对象和生成的ID创建一个新的Obj，然后将两个obj对象传输给事务发送方。一旦传输了对象，它就会流到全局对象池中，并且在事务的其余部分中不能通过代码访问。Transfer模块是Sui标准库的一部分，它包含了将对象传输到用户地址和其他对象的函数。

我们注意到，如果程序员代码忽略了包含一个转移调用，那么Move的类型系统将会拒绝该代码。Move强制资源安全保护，以确保在没有权限的情况下不能创建、复制或意外销毁对象。资源安全的另一个例子是试图两次传输相同的对象，这也会被Move类型系统拒绝。


## 3.自编程模型

在本节中，我们将通过详细的语义定义来扩展第2节中对Sui编程模型的非正式描述。上一节展示了Move源代码的示例，示例里定义了Move字节码的结构。开发人员在本地编写、测试并正式验证Move源码，然后将其编译为字节码，再将其发布到区块链。任何发布在链上的Move字节码必须通过字节码验证器，以确保它满足关键属性，如类型、内存和资源安全。

正如在第2节中提到的，Move是一种平台无关的语言，它可以适应不同系统的特定需求，而不需要创建核心语言。在下面的描述中，我们从核心的Move语言(用黑色表示)中定义了这两个概念以及扩展核心Move语言的Sui-specific特性 (Instr 后的值 )。


### 3.1 模块
```java
Module = ModuleName×
(StructName ⇀ StructDecl)×
(FunName ⇀ FunDecl) × FunDecl
GenericParam = [Ability]
StructDecl = (FieldName ⇀ StorableType)×
[Ability] × [GenericParam]
FunDecl = [Type] [Type] × [Instr] × [GenericParam]
Instr = TransferToAddr | TransferToObj | ShareMut | ShareImmut | . . .

```

Move代码被组织到模块中，其结构定义如上所示。一个模块由一组命名结构体声明和一组命名函数声明组成(这些声明的例子在第2.1节中提供)。
模块还包含一个特殊的函数声明，作为模块初始化器。这个函数在模块发布到链上时只调用一次。

结构声明是命名字段的集合，其中字段名映射到可存储类型。它的声明还包括一个可选的能力列表(参见第2节的可存储类型和能力的描述)。struct声明还可以包括具有能力约束的泛型参数列表，在这种情况下，我们称其为泛型struct声明，例如struct Wrapper<T: copy>{T: T}。

泛型参数表示在声明结构字段时要使用的类型——在声明结构时它是未知的，而在实例化结构时提供了具体类型(例如：创建结构值时)。

函数声明包括形参类型列表、返回类型列表和组成函数体的指令列表。函数声明还可以包括具有能力约束的泛型参数列表，在这种情况下，我们称其为泛型函数声明，例如fun unwrap<T: copy>(p: Wrapper<T>){}。与struct声明类似，泛型形参表示在函数声明时未知的类型，但在声明函数形参、返回值和函数体时使用(在调用函数时提供具体类型)。

可以出现在函数体中的指令包括所有普通的Move指令，但全局存储指令除外(例如，move_to, move_from, borrow_global)。请参阅结尾的Move指令集以获得核心Move指令及其语义的完整列表。在Sui中，持久存储是通过Sui的全局对象池来支持的，而不是核心Move中基于账户的全局存储。

有四个特定于sui的对象操作。这些操作都会改变对象的所有权元数据(参见3.3节)，并将其返回给全局对象池。

最简单的是，一个Sui对象可以被转移到一个Sui最终用户的地址。对象还可以被转移到另一个父对象—此操作要求调用方提供对中父对象的可变引用添加到子对象。对象可以被可变地共享，因此它可以被Sui系统中的任何人读/写。最后，一个对象可以不可更改地共享，这样它就可以被Sui系统中的任何人读取，但不能被任何人编写。

区分不同类型所有权的能力是Sui的一个独特特征。在我们知道的其他区块链平台中，每个合约和对象都是可变地共享的。正如我们将在第4节中解释的，Sui利用该信息进行并行事务执行(针对所有事务)和并行协议(针对涉及没有共享可变性的对象的事务)。


### 3.2 类型与能力

```java
    PrimType = {address, id, bool, u8, u64, . . .}
    StructType = ModuleName × StructName× [StorableType]
    StorableType = PrimType ⊎ StructType⊎
    GenericType ⊎ VectorType
    VectorType = StorableType
    GenericType = N
    MutabilityQual = {mut, immut}
    ReferenceType = StorableType × MutabilityQual
    Type = ReferenceType ⊎ StorableType
    Ability = {key, store, copy, drop}
```

Move程序操作存储在Sui全局对象池中的数据和在Move程序运行时创建的瞬时数据。对象和瞬时数据在语言层面上都是表示值。然而，并不是所有的值都是相同的 -- 他们可能具有不同的属性和不同的结构。

Move中使用的类型定义在上表中展示。Move支持其他编程语言支持的许多相同的基本类型，比如布尔类型或者其他各种大小的无符号整数类型。此外，Move有一个表示系统中最终用户(end-user)的地址类型，也用来表示交易的发送者和(Sui)对象的所有者。最后Sui定义了一个表示Sui对象标识的id类型 -- 详细信息请参见3.3节。

结构类型描述了一个实例（比如一个值）在给定的模块中声明的结构体（参见3.1节了解结构体声明的信息）。表示泛型结构声明的结构类型（比如泛型结构类型）包含一个可存储类型列表 -- 这个列表与结构声明中的泛型参数列表对应。可存储类型可以是具体类型（一个基础类型或者结构），也可以是泛型。我们称此类类型为可存储的，因为它们可以作为结构体的字段或持久化存储在链上的对象中，而引用类型则不能。

例如，`Wrapper<u64>`是一个泛型结构类型，参数化了一个具体的（原始的）可存储类型u64 -- 这种类型可以用来创建一个结构实例(比如值)。另一方面，相同的泛型结构类型可以通过泛型类型(比如`struct Parent<T> { w: Wrapper<T> }`)进行参数化外部结构或函数声明的泛型参数 - 这种类型可用于声明结构字段、函数参数等。在结构上，泛型类型是封闭结构或函数声明中泛型参数列表的整数索引。

Move中的vector类型描述为同一种类型值的一个可变长度集合。Move的vector只能包含可存储类型，而且它本身也是一个可存储类型。

Move程序可以直接操作值或者通过引用间接访问他们。引用类型包括引用的可存储类型和用于确定(和强制)给定类型的值是可读可写(mut)还是只读(imut)的可变性限定符。因此，Move值类型的一般形式可以是可存储类型或者引用类型。

最后，Move中的能力控制给定类型的值允许哪些操作，例如给定类型的值是否可以复制。能力约束结构声明和泛型类型参数。Move字节码验证器负责确保像拷贝这样的敏感操作只能在具有相应能力的类型上执行。

### 3.3 对象和所有权

```java
    TxDigest = 𝐶𝑜𝑚(Tx)
    ObjID = 𝐶𝑜𝑚(TxDigest × N)
    SingleOwner = Addr ⊎ ObjID
    Shared = {shared_mut, shared_immut}
    Ownership = SingleOwner ⊎ Shared
    StructObj = StructType × Struct
    ObjContents = StructObj ⊎ Package
    Obj = ObjContents × ObjID × Ownership × Version
```

每个Sui对象都有一个全局唯一的标识符(ObjID)。作为对象的持久标识符，它在所有者之间流动并在其他对象中进出。这个ID是由创建它的事务分配给对象的。对象ID是通过将一个抗碰撞哈嘻函数应用到当前事务的内容和一个记录事务已经创建了多少个对象的计数器来创建的。由于事务的输入对象受到限制，事务（及其摘要）保证是唯一的，我们将在后面解释这一点。

除了ID之外，每个对象都携带关于其所有权的元数据。对象要么由一个地址或者另一个对象唯一拥有，要么共享读写权限，要么共享只读权限。对象的所有权决定事务是否以及如何将其用作输入。一般来说，唯一拥有的对象只能用于由其所有者发起的事务中，或将其父对象作为输入，而共享对象可以用于任何事务，但必须具有指定的可变性权限。详细解释请看4.4节。

有两种类型的对象：包代码对象和结构数据对象。包对象包含一个模块列表。一个结构对象包含一个Move值和该值的Move类型。

对象的内容可能会改变，但是它的ID、对象类型(package vs struct)和Move结构类型是不可变的。这确保了对象是强类型的，并且具有持久的标识。

最后，对象包含一个版本。新创建的对象的版本为0，每次事务接受对象作为输入时，对象的版本就会递增。

### 3.4 地址和验证者

```java
    Authenticator = Ed25519PubKey ⊎ ECDSAPubKey ⊎ . . .
    Addr = 𝐶𝑜𝑚(Authenticator)
```
地址是Sui最终用户的持久标识(尽管注意单个用户可以有任意数量的地址)。若要将对象传输给另一个用户，发送方必须知道接收方的地址。
正如我们稍后将讨论的，Sui事务必须包含用户发送的地址(比如初始化)事务和摘要与地址匹配的验证器。地址和身份验证器之间的分离使得加密的灵活性得以实现。

验证者可以是来自任何签名方案的公钥，即使这些方案使用不同的密钥长度(例如，支持后量子签名(postquantum signatures))。

此外，验证者不必是单一的公钥——它也可以是(例如)K-of-N多重sig密钥。

### 3.5 交易

```java
    ObjRef = ObjID × Version × 𝐶𝑜𝑚(Obj)
    CallTarget = ObjRef × ModuleName × FunName
    CallArg = ObjRef ⊎ ObjID ⊎ PrimType
    Package = [Module]
    Publish = Package × [ObjRef]
    Call = CallTarget × [StorableType] × [CallArg]
    GasInfo = ObjRef × MaxGas × BaseFee × Tip
    Tx = (Call ⊎ Publish) × GasInfo × Addr × Authenticator
```

Sui有两种不同的事务类型:发布一个新的Move包，以及调用一个之前发布的Move包。

发布事务包含一个包——一组将作为单个对象一起发布的模块，以及这个包中所有模块的依赖关系(编码为必须引用已经发布的包对象的对象引用列表)。

要执行发布事务，Sui运行时将在每个包上运行Move字节码验证器，将包与它的依赖项链接起来，并运行每个模块的模块初始化器。模块初始化器对于引导由包实现的应用程序的初始状态非常有用。

调用事务最重要的参数是对象输入。对象参数可以通过对象引用(对于单一所有者和共享的不可变对象)或对象ID(对于共享的可变对象)指定。

对象引用由对象组成ID、对象版本和对象值的哈希值。Sui运行时将对象ID和对象引用解析为存储在全局对象池中的对象值。对于对象引用，运行时将根据池中对象的版本检查引用的版本，并检查引用的散列是否与池对象匹配。这确保了对象的运行时视图与事务发送方的对象视图相匹配。

此外，调用事务接受类型参数和纯值参数。类型参数实例化要调用的入口点函数的泛型类型参数(例如，如果入口点函数`send_coin<T>(c: Coin<T>，…)`，泛型类型参数T可以用类型参数SUI实例化，以发送SUI原生token)。纯值可以包括基元类型和基元类型的向量，但不包括结构类型。

调用要调用的函数是通过对象引用(必须指向一个包对象)、包中的模块名和包中的函数名指定的。要执行调用事务，Sui运行时将解析函数，将类型、对象和值参数绑定到函数参数，并使用Move VM执行函数。
调用和发布交易都受gas计量和gas费用的影响。计量限制用最大gas预算表示。运行时将执行事务，直到达到预算为止，如果预算耗尽，则将中止而不产生任何影响(除了扣除费用并报告中止代码)。

费用从指定为对象参考的气体对象中扣除。该对象必须是Sui的本地令牌(即类型必须为Coin<SUI>)。Sui使用eip1559风格的费用:该协议定义了一个基本费用(以每个Sui代币的天然气单位计算)，在纪元边界进行算法调整，交易发送者也可以包括一个可选的小费(以Sui代币计算)。在正常的系统负载下，即使没有提示，事务也会被及时处理。但是，如果系统拥塞，则小费较多的事务将被优先处理。气体对象的总费用是(GasUsed * BaseFee) + Tip。

### 3.6 交易的影响

```java
    Event = StructType × Struct
    Create = Obj
    Update = Obj
    Wrap = ObjID × Version
    Delete = ObjID × Version
    ObjEffect = Create ⊎ Update ⊎ Wrap ⊎ Delete
    AbortCode = N × ModuleName
    SuccessEffects = [ObjEffect] × [Event]
    AbortEffects = AbortCode
    TxEffects = SuccessEffects ⊎ AbortEffects
```

事务执行产生的事务效果在事务成功执行(上面的SuccessEffects)和不成功执行(上面的AbortEffects)时是不同的。

事务成功执行后，事务效果包括对Sui的全局对象池所做的更改(包括对现有对象和新创建对象的更新)和事务执行期间生成的事件的信息。

事务执行成功的另一个影响可能是对象从全局对象池里删除(比如deletion)并且包装一个对象(比如embedding)到另一个对象里,这与移除有类似的效果——被包装的对象从全局池中消失，只作为包装它的对象的一部分存在。由于已删除和封装的对象在全局池中不再可访问，因此这些效果由对象的ID和版本表示。

事件编码成功执行事务的连锁反应，而不仅仅是更新全局对象池。

在结构上，一个事件由一个Move结构体及其类型组成。事件旨在由区块链之外的参与者使用，但Move程序不能读取事件。

交易有一个原子性的语义,如果执行事务中止在某种情况下(例如,由于一个意想不到的失败),即使发生了一些改变对象(或一些事件生成的)这一点之前,这些影响坚持一个失败的事务。相反，中止的事务效果包括一个数字中止代码和发生事务中止的模块的名称。中止交易仍需收取gas费。
